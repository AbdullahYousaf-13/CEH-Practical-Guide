# Module 7

## Malware Threats
With the help of a malicious application (malware), an attacker gains access to stored passwords in a computer and is able to read personal documents, delete files, display pictures or messages on the screen, slow down computers, steal personal information, send spam, and commit fraud. Malware can perform various malicious activities that range from simple email advertising to complex identity theft and password stealing.

**Objective**
Understand how malware functions, its purposes, and the potential damage it can cause to individuals and organizations.

**Approach**
Analyze malware behavior in a controlled lab environment using tools like Flare VM to study infection methods, propagation, and impact.

### Purposes of Malware
- Attack browsers and track websites visited  
- Affect system performance, making it very slow  
- Cause hardware failure, rendering computers inoperable  
- Steal personal information, including contacts  
- Erase valuable information, resulting in substantial data losses  
- Attack additional computer systems directly from a compromised system  
- Spam inboxes with advertising emails  

---

### 1. Gain Access to Systems with Trojans
The lab tasks in this exercise demonstrate how easily attackers can gain access to target systems in an organization and create covert communication channels for transferring sensitive data.

---

### 1.1 Gain Control over a Victim Machine using the njRAT Trojan
njRAT is a Remote Access Trojan (RAT) with powerful data-stealing capabilities. In addition to logging keystrokes, it can access a victim’s camera, steal credentials stored in browsers, upload and download files, perform process and file manipulations, and view the victim’s desktop.

**Steps Involved**
1. Download and run the trojan software. A [Port Now] pop-up appears, leave the port number to default and click on OK.
2. The njRAT GUI appears; click the [Build] button located in the lower-left corner of the GUI to configure the exploit details.
3. The Builder dialog-box appears; enter the IP address of the Windows 11 (attacker machine) machine in the Host field, check the options Randomize Stub, USB Spread Nj8d, Protect Prosess [BSOD], leave the other settings to default, and click Build.
> In this task, the IP address of the Windows 11 machine is 10.10.1.11.
4. The Save As window appears; specify a location to store the server, rename it, and click Save.
5. In this lab, the destination location chosen is Desktop, and the file is named Test.exe.
6. Once the server is created, the Done Successfully! pop-up appears; click OK.
> A Server pop-up appears, click OK.
7. Now, use any technique to send this server to the intended target through email or any other source (in real-time, attackers send this server to the victim).
8. Here, you are acting both as an attacker who logs into the Windows 11 machine to create a malicious server, and as a victim who logs into the Windows Server 2022 machine and downloads the server.
9. Double-click the server (Test.exe) to run this malicious executable.
10. Click Windows 11 to switch back to the Windows 11 machine. Maximize njRAT GUI window. As soon as the victim (here, you) double-clicks the server, the executable starts running and the njRAT client (njRAT GUI) running in Windows 11 establishes a persistent connection with the victim machine, as shown in the screenshot.
11. Unless the attacker working on the Windows 11 machine disconnects the server on their own, the victim machine remains under their control.
12. The GUI displays the machine’s basic details such as the IP address, User name, and Type of Operating system.
13. Right-click on the detected victim name and hover the cursor over Manager and click File Manager from context menu.
14. The File Manager window appears. Double-click any directory in the left pane (here, ProgramData); all its associated files and directories are displayed in the right pane. You can right-click a selected directory and manipulate it using the contextual options. Close the File Manager window.
15. Right-click on the detected victim name and click hover the cursor over Manager and click Process Manager from context menu.
16. You will be redirected to the Process Manager, where you can click on a selected process and perform actions such as Suspend, Kill + Delete, Kill, and Refresh.
17. Close the Process Manager window.
18. Right-click on the detected victim name and click hover the cursor over Manager and click Registry from context menu.
19. Window showing the registries folders will be opened, choose a registry directory from the left pane, and right-click on its associated registry files.
20. A few options appear for the files; you can use these to manipulate them. Close the window displaying Registry folders.
21. Right-click on the detected victim name and hover the cursor over Manager and click Remote Shell from context menu.
22. This launches a remote command prompt for the victim machine (Windows Server 2022).
23. In the text field present in the lower section of the window, type the command ipconfig/all and press Enter.
24. This displays all interfaces related to the victim machine, as shown in the screenshot.
25. Similarly, you can issue all other commands that can be executed in the command prompt of the victim machine. Close the Remote Shell window.

### 1.2 Hide a Trojan using SwaysCryptor
Used to obfuscate and conceal trojan executables from detection.

### 1.3 TheefRAT Trojan
Start the server on the victim and then use the client to connect to it.

---

### 2. Infect the system using Virus
Viruses are the scourges of modern computing. Computer viruses have the potential to wreak havoc on both business and personal computers.

#### 2.1 Create a Virus using the JPS Virus Maker Tool and Infect the Target System
The JPS Virus Maker tool is used to create its own customized virus. This tool has many options for building that can be used to create a virus. Some of the tool’s features are auto-start, shutdown, disable security center, lock mouse and keyboard, destroy protected storage, and terminate windows. An ethical hacker and pen-tester can use the JPS Virus Maker Tool as a proof of concept to audit perimeter security controls in an organization.

<img width="414" height="608" alt="image" src="https://github.com/user-attachments/assets/21f60e19-4073-4c80-98ab-396ae8e1fb9a" />

<img width="408" height="577" alt="image" src="https://github.com/user-attachments/assets/692e6ad2-555b-472c-b267-e8a0870386ad" />

---

### 3. Perform Static Malware Analysis
Static Malware Analysis, also known as code analysis, involves going through the executable binary code without executing it to gain a better understanding of the malware and its purpose.

#### 3.1 Perform Malware Scanning using Hybrid Analysis
[Free Automated Malware Analysis Service - powered by Falcon Sandbox](https://www.hybrid-analysis.com/)
You can upload a file and it will perform the analysis.  
You can also use other local and online malware scanning tools such as **Any.Run** (https://app.any.run), **Valkyrie Sandbox** (https://valkyrie.comodo.com), **JOESandbox Cloud** (https://www.joesandbox.com), and **Jotti** (https://virusscan.jotti.org) to perform online malware scanning.

#### 3.2 Perform Strings Search using BinText
[bintext.zip ≈ Packet Storm](https://packetstormsecurity.com/files/23823/bintext.zip.html)
Open file in BinText and make sure that advanced option is set. Click on **Go**.

#### 3.3 Identify Packaging and Obfuscation with PEid
Attackers often use packing and obfuscation or a packer to compress, encrypt, or modify a malware executable file to avoid detection.
Obfuscation also hides the execution of the programs. When the user executes a packed program, it also runs a small wrapper program to decompress the packed file, and then runs the unpacked file.  
It complicates the task of reverse engineers to determine the actual program logic and other metadata via static analysis.  
The best approach is to try and identify if the file includes packed elements and locate the tool or method used to pack it.  

PEid is a free tool that provides details about Windows executable files. It can identify signatures associated with over 600 different packers and compilers. This tool also displays the type of packer used in packing a program.

#### 4. Analyze ELF Executable with Detect it Easy (DIE)
The Executable and Linkable Format (ELF) is a generic executable file format in Linux environment. It contains three main components including ELF header, sections, and segments. Each component plays an independent role in the loading and execution of ELF executables.  

The static analysis of an ELF file involves investigating an ELF executable file without running or installing it. It also involves accessing the binary code and extracting valuable artifacts from the program.  

Detect It Easy (DIE) is an application used for determining the types of files. Apart from Windows, DIE is also available for Linux and Mac OS. It has a completely open architecture of signatures and can easily add its own algorithms for detecting or modifying the existing signatures. It detects a file's compiler, linker, packer, etc. using a signature-based detection method.

Steps:
1. **Detect It Easy** automatically scans the file and result appears showing the Operating system, compiler and language details in the middle pane.
2. Now, check the **Advanced** checkbox present at the right pane.
3. Click **File info** button from the top left corner of the window. Info window appears, you can observe information such as File name, size, MD5, SHA1, Entropy, entry points, etc.
4. After viewing the information, close the window.
5. Similarly, click **Hash** button from the top right corner of the window to view the information related to hash. Close the window after viewing the information.
6. Click **Entropy** button from the top right corner of the window. Here, you can observe the status, size and graph of entropy. Close the window after viewing the Entropy information.
7. Similarly, you can further explore other functions such as MIME, Hex, Signatures and Demangle.

#### 5. Find the Portable Executable Information with PE Explorer
The Portable Executable (PE) format is the executable file format used on Windows OSes that stores the information a Windows system requires to manage the executable code.  
The PE stores metadata about the program, which helps in finding additional details of the file. For instance, the Windows binary is in PE format that consists of information such as time of creation and modification, import and export functions, compilation time, DLLs, and linked files, as well as strings, menus, and symbols.  

PE Explorer lets you open, view, and edit a variety of different 32-bit Windows executable file types (also called PE files) ranging from common such as EXE, DLL, and ActiveX Controls to less familiar types such as SCR (Screensavers), CPL (Control Panel Applets), SYS, MSSTYLES, BPL, DPL, and more (including executable files that run on MS Windows Mobile platform).

#### 6. Identify File Dependencies using Dependency Walker
Any software program depends on the various inbuilt libraries of an OS that help in performing specified actions in a system. Programs need to work with internal system files to function correctly.  

Programs store their import and export functions in a kernel32.dll file. File dependencies contain information about the internal system files that the program needs to function properly; this includes the process of registration and location on the machine.  

Find the libraries and file dependencies, as they contain information about the run-time requirements of an application. Then, check to find and analyze these files to provide information about the malware in the file. File dependencies include linked libraries, functions, and function calls.  

Finding out all library functions may allow guessing about what the malware program can do. You should know the various DLLs used to load and run a program. Some of the standard DLLs are:

#### 7. Malware Disassembly using IDA and OllyDbg
Static analysis also includes the dismantling of a given executable into binary format to study its functionalities and features. This process helps identify the language used for programming the malware, look for APIs that reveal its function, and retrieve other information.  

This process uses debugging tools such as IDA Pro and OllyDbg.

**IDA**  
As a disassembler, IDA explores binary programs, for which the source code might not be available, to create maps of their execution. The primary purpose of a disassembler is to display the instructions actually executed by the processor in a symbolic representation called “assembly language.”  

Viruses, worms, and Trojans are often armored and obfuscated; as such, more powerful tools are required. The debugger in IDA complements the static analysis capabilities of the disassembler. By allowing an analyst to single-step through the code being investigated, the debugger often bypasses the obfuscation.  

**OllyDbg**  
OllyDbg emphasizes binary code analysis, useful when source code is unavailable. It traces registers, recognizes procedures, API calls, switches, tables, constants, and strings, and locates routines from object files and libraries.

Steps:
1. Launch **IDA Freeware 8.4.**
2. The **IDA: Quick start** pop-up appears; click on **New** to select a malicious file for disassembly.
3. The **IDA** main window appears, along with the **Select file to disassemble** window.
4. In the **Select file to disassemble** window, select **face.exe**, and click **Open**.
5. The **Load a new file** window appears; by default, the **Portable executable for 80386 (PE) [pe64.dll]** option is selected; click **OK**.
6. IDA completes the analysis of the imported malicious file and displays the results in the **IDA View-A** tab.
7. In the **IDA View-A** section, right-click anywhere and choose **Text view** from the context menu.
8. This reveals the text view of the malicious file, allowing analysis of its information.
9. Maximize the IDA window. To view the flow of the uploaded malicious file, navigate to **View** → **Graphs** → **Flow chart**.
10. A **Graph** window appears with the flow. You may zoom in and adjust the screen.
11. Close the **Graph** window, go to **View** → **Graphs** → **Function calls**.
12. A window showing **call flow** appears; zoom in for a better view. Close when done.
13. Click the **HexView-1** tab to view the hex value of the malicious file.
14. Click the **Imports** tab to view list of all functions that the executable calls.
15. Close all open windows. In the **Save database** pop-up, click **OK**.
16. Navigate to **Ollydbg.exe** and run it.
17. If a **Old DLL** dialog box appears, click **Yes**.
18. If an OllyDbg warning message appears, click **OK**.
19. The **OllyDbg** main window appears.
20. Choose **File** → **Open**.
21. Select **tini.exe**, and click **Open**.
22. The output appears in a window named **CPU - main thread, module tini**.
23. Choose **View** → **Log**.
24. The **Log data** window appears, displaying log details and function calls.
25. The **Log data** also displays the program entry point and calls to known functions. Close the **Log data** window.
26. Choose **View** → **Executable modules**.
27. A window named **Executable modules** appears, displaying all modules.
28. Double-click any module to view its complete information.
29. Select the **75750000** module (results may differ).
30. This redirects you to the **CPU - main thread** window.
31. Choose **View** → **Memory map**.
32. The **Memory map** window appears, displaying all memory mappings. Close the window.
33. Choose **View** → **Threads**.
34. A window named **Threads** appears, displaying all threads.
35. This way, you can scan files and analyze the output using OllyDbg.

#### 8. Malware Disassembly using Ghidra
Ghidra is a software reverse engineering (SRE) framework that includes a suite of full-featured, high-end software analysis tools that enable users to analyze compiled code on a variety of platforms including Windows, MacOS, and Linux.  

Its capabilities include disassembly, assembly, decompilation, debugging, emulation, graphing, and scripting. Ghidra supports a wide variety of processor instruction sets and executable formats and can be run in both user-interactive and automated modes.  

Analysts can also develop their own Ghidra plug-in components or scripts using the exposed API. In addition, there are numerous ways to extend Ghidra such as new processors, loaders/exporters, automated analyzers, and new visualizations.
